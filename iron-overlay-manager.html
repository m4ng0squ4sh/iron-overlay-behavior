<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<script>

  /**
   * @struct
   * @constructor
   */
  Polymer.IronOverlayManagerClass = function() {
    this._overlays = [];

    /**
     * iframes have a default z-index of 100, so this default should be at least
     * that.
     * @private {number}
     */
    this._minimumZ = 101;

    this._backdropElement = null;
    Object.defineProperty(this, 'backdropElement', {
      get: function() {
        if (!this._backdropElement) {
          this._backdropElement = document.createElement('iron-overlay-backdrop');
        }
        return this._backdropElement;
      }.bind(this)
    });

    /**
     * The deepest active element.
     * returns {?Node} element the active element
     */
    this.deepActiveElement = null;
    Object.defineProperty(this, 'deepActiveElement', {
      get: function() {
        // document.activeElement can be null
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
        // In case of null, default it to document.body.
        var active = document.activeElement || document.body;
        while (active.root && Polymer.dom(active.root).activeElement) {
          active = Polymer.dom(active.root).activeElement;
        }
        return active;
      }.bind(this)
    });

    // Enable document-wide tap recognizer.
    Polymer.Gestures.add(document, 'tap', null);
    // We should be using only 'tap', but this would be a breaking change.
    var tapEvent = ('ontouchstart' in window) ? 'tap' : 'click';
    document.addEventListener(tapEvent, this._onCaptureClick.bind(this), true);
    document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
  };

  /**
   * track overlays for z-index and focus managemant
   */
  Polymer.IronOverlayManagerClass.prototype.addOverlay = function(overlay) {
    var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
    this._overlays.push(overlay);
    var newZ = this.currentOverlayZ();
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    var element = this.deepActiveElement;
    overlay.restoreFocusNode = this._overlayParent(element) ? null : element;
  };

  Polymer.IronOverlayManagerClass.prototype.removeOverlay = function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._overlays.splice(i, 1);
      this._setZ(overlay, '');

      var node = overlay.restoreFocusOnClose ? overlay.restoreFocusNode : null;
      overlay.restoreFocusNode = null;
      // Focus back only if still contained in document.body
      if (node && Polymer.dom(document.body).deepContains(node)) {
        node.focus();
      }
    }
  };

  Polymer.IronOverlayManagerClass.prototype.currentOverlay = function() {
    var i = this._overlays.length - 1;
    return this._overlays[i];
  };

  Polymer.IronOverlayManagerClass.prototype.currentOverlayZ = function() {
    return this._getZ(this.currentOverlay());
  };

  /**
   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
   * This does not effect the z-index of any existing overlays.
   *
   * @param {number} minimumZ
   */
  Polymer.IronOverlayManagerClass.prototype.ensureMinimumZ = function(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  };

  Polymer.IronOverlayManagerClass.prototype.focusOverlay = function() {
    var current = this.currentOverlay();
    // We have to be careful to focus the next overlay _after_ any current
    // transitions are complete (due to the state being toggled prior to the
    // transition). Otherwise, we risk infinite recursion when a transitioning
    // (closed) overlay becomes the current overlay.
    //
    // NOTE: We make the assumption that any overlay that completes a transition
    // will call into focusOverlay to kick the process back off. Currently:
    // transitionend -> _applyFocus -> focusOverlay.
    if (current && !current.transitioning) {
      current._applyFocus();
    }
  };

  Polymer.IronOverlayManagerClass.prototype.trackBackdrop = function(element) {
    this.backdropElement.style.zIndex = this.backdropZ();
  };

  Polymer.IronOverlayManagerClass.prototype.getBackdrops = function() {
    var backdrops = [];
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        backdrops.push(this._overlays[i]);
      }
    }
    return backdrops;
  };

  /**
   * Returns the z-index for the backdrop.
   */
  Polymer.IronOverlayManagerClass.prototype.backdropZ = function() {
    return this._getZ(this._overlayWithBackdrop()) - 1;
  };

  /**
   * Returns the first opened overlay that has a backdrop.
   */
  Polymer.IronOverlayManagerClass.prototype._overlayWithBackdrop = function() {
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        return this._overlays[i];
      }
    }
  };

  /**
   * Calculates the minimum z-index for the overlay.
   */
  Polymer.IronOverlayManagerClass.prototype._getZ = function(overlay) {
    var z = this._minimumZ;
    if (overlay) {
      var z1 = Number(window.getComputedStyle(overlay).zIndex);
      // Check if is a number
      // Number.isNaN not supported in IE 10+
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  };

  Polymer.IronOverlayManagerClass.prototype._setZ = function(element, z) {
    element.style.zIndex = z;
  };

  Polymer.IronOverlayManagerClass.prototype._applyOverlayZ = function(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 2);
  };

  /**
   * Returns the overlay containing the provided node. If the node is an overlay,
   * it returns the node.
   * @private
   * @param {Node} node
   * @returns {?Node} overlay
   */
  Polymer.IronOverlayManagerClass.prototype._overlayParent = function(node) {
    while (node && node !== document.body) {
      // Check if it is an overlay.
      if (node.behaviors && node.behaviors.indexOf(Polymer.IronOverlayBehaviorImpl) !== -1) {
        return node;
      }
      // Use logical parentNode, or native ShadowRoot host.
      node = Polymer.dom(node).parentNode || node.host;
    }
  };

  /**
   * @private
   * Ensures the click event is delegated to the right overlay.
   */
  Polymer.IronOverlayManagerClass.prototype._onCaptureClick = function(event) {
    var overlay = this.currentOverlay();
    // Check if clicked outside of any overlay.
    var target = Polymer.dom(event).rootTarget;
    if (overlay && this._overlayParent(target) !== overlay) {
      overlay._onCaptureClick(event);
    }
  };

  /**
   * @private
   * Ensures the focus event is delegated to the right overlay.
   */
  Polymer.IronOverlayManagerClass.prototype._onCaptureFocus = function(event) {
    var overlay = this.currentOverlay();
    if (overlay) {
      overlay._onCaptureFocus(event);
    }
  };

  Polymer.IronOverlayManager = new Polymer.IronOverlayManagerClass();

</script>
